<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Repo2Prompt | McIndi WebUtils</title>
    <style>

      :root {
        --bg: #f3f1ed;
        --ink: #111418;
        --muted: #626a73;
        --panel: #fbf7f2;
        --stroke: #e2d8cf;
        --accent: #c6562a;
        --accent-dark: #a14320;
        --accent-soft: rgba(198, 86, 42, 0.16);
        --warn: #b9382e;
        --brand-deep: #0f1720;
        --brand-fade: rgba(15, 23, 32, 0.08);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Work Sans", "Manrope", "Segoe UI", sans-serif;
        color: var(--ink);
        background: radial-gradient(900px 600px at 10% -10%, #f6d9c4 0%, transparent 60%),
          radial-gradient(700px 500px at 120% 10%, #d4e9e5 0%, transparent 60%),
          var(--bg);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        width: 100%;
        padding: 28px 24px 10px;
        margin: 0;
        display: grid;
        gap: 10px;
      }

      .brand-bar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
      }

      .brand-link {
        display: inline-flex;
        align-items: center;
        gap: 10px;
        text-decoration: none;
        color: var(--brand-deep);
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        font-size: 0.75rem;
      }

      .brand-mark {
        width: 30px;
        height: 30px;
        border-radius: 9px;
        background: var(--brand-deep);
        color: #fff;
        display: grid;
        place-items: center;
        font-weight: 700;
        font-size: 0.8rem;
        box-shadow: 0 10px 20px var(--brand-fade);
      }

      .brand-subtitle {
        font-size: 0.9rem;
        color: var(--muted);
      }

      header h1 {
        margin: 0;
        font-family: "Fraunces", "Iowan Old Style", "Palatino", serif;
        font-size: clamp(2rem, 4vw, 3rem);
      }

      header p {
        margin: 0;
        color: var(--muted);
        line-height: 1.6;
      }

      .toolbar {
        width: 100%;
        margin: 0;
        padding: 0 24px 18px;
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }

      .toolbar input[type="url"] {
        flex: 1 1 320px;
        min-width: 240px;
        font: inherit;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: #fff;
      }

      .toolbar input[type="file"] {
        display: none;
      }

      .toolbar button,
      .toolbar a,
      .toolbar label {
        border: 1px solid var(--stroke);
        background: #fff;
        padding: 10px 16px;
        border-radius: 12px;
        cursor: pointer;
        font-weight: 600;
        text-decoration: none;
        color: var(--ink);
      }

      .toolbar .primary {
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }

      .toolbar .danger {
        color: var(--warn);
        border-color: var(--warn);
      }

      .toolbar .status {
        flex-basis: 100%;
        color: var(--muted);
        font-size: 0.9rem;
      }

      .toolbar .status-progress {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .toolbar .status-progress[hidden] {
        display: none;
      }

      .toolbar .status-progress progress {
        width: 210px;
        height: 10px;
      }

      main {
        width: 100%;
        margin: 0;
        padding: 0 24px 32px;
        display: grid;
        gap: 16px;
        grid-template-columns: var(--split-pos, 380px) minmax(0, 1fr);
        min-height: 0;
        position: relative;
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--stroke);
        border-radius: 16px;
        padding: 16px;
        display: grid;
        gap: 14px;
        align-content: start;
        min-height: 0;
      }

      .panel h2 {
        margin: 0;
        font-size: 1rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
      }

      .file-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 10px;
        overflow: auto;
      }

      .file-row {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 8px;
        align-items: start;
        padding: 6px 8px;
        border-radius: 12px;
        border: 1px solid var(--stroke);
        background: #fff;
      }

      main.resizing {
        user-select: none;
      }

      .resize-handle {
        position: absolute;
        width: 4px;
        height: 100%;
        cursor: col-resize;
        left: calc(var(--split-pos, 380px) - 2px);
        background: transparent;
      }

      .resize-handle:hover {
        background: var(--accent);
      }

      .file-row label {
        display: grid;
        gap: 4px;
        font-size: 0.95rem;
        min-width: 0;
      }

      .file-title {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .file-meta {
        color: var(--muted);
        font-size: 0.8rem;
      }

      .file-controls {
        display: grid;
        gap: 8px;
      }

      .file-controls button {
        border: 1px solid var(--stroke);
        background: #fff;
        padding: 6px 10px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 600;
      }

      .file-controls button:hover {
        background-color: var(--accent-soft);
      }

      .file-controls details {
        border: 1px solid var(--stroke);
        border-radius: 10px;
        padding: 8px;
      }

      .file-controls summary {
        cursor: pointer;
        font-weight: 600;
        font-size: 0.85rem;
        color: var(--muted);
      }

      .file-controls #extension-filters {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 6px;
        margin-top: 8px;
      }

      .file-controls #extension-filters label {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 0.9rem;
      }

      .output-header {
        display: flex;
        flex-wrap: nowrap;
        gap: 8px;
        align-items: center;
      }

      .output-header h2 {
        line-height: 1;
      }

      .output-header .size {
        color: var(--muted);
        font-size: 0.9rem;
        white-space: nowrap;
      }

      .output-header button {
        margin-left: auto;
        border: 1px solid var(--stroke);
        background: var(--accent);
        color: #fff;
        padding: 8px 14px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
      }

      textarea {
        width: 100%;
        min-height: 360px;
        border-radius: 14px;
        border: 1px solid var(--stroke);
        padding: 12px;
        font: 0.95rem/1.5 "Consolas", "Courier New", monospace;
        background: #fff;
        resize: vertical;
      }

      .empty {
        color: var(--muted);
        font-size: 0.9rem;
      }

      dialog {
        border: none;
        border-radius: 16px;
        padding: 0;
        width: min(520px, 92vw);
        box-shadow: 0 20px 40px rgba(30, 27, 24, 0.25);
      }

      dialog::backdrop {
        background: rgba(30, 27, 24, 0.35);
      }

      .confirm-form {
        padding: 18px;
        display: grid;
        gap: 12px;
      }

      .confirm-form h3 {
        margin: 0;
        font-size: 1.1rem;
      }

      .confirm-form p {
        margin: 0;
        color: var(--muted);
      }

      .confirm-actions {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
      }

      .confirm-actions button {
        border: 1px solid var(--stroke);
        background: #fff;
        padding: 8px 14px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
      }

      .confirm-actions .primary {
        background: var(--accent);
        color: #fff;
        border-color: var(--accent);
      }

      footer {
        padding: 12px 24px 24px;
        color: var(--muted);
        font-size: 0.85rem;
      }

      footer a {
        color: inherit;
        text-decoration: none;
        font-weight: 600;
      }

      @media (max-width: 900px) {
        main {
          grid-template-columns: 1fr;
        }
      }

      @media (max-width: 720px) {
        .output-header {
          flex-wrap: wrap;
        }

        .output-header button {
          margin-left: 0;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="brand-bar">
        <a class="brand-link" href="https://www.mcindi.com" target="_blank" rel="noopener">
          <span class="brand-mark">M</span>
          McIndi Solutions
        </a>
        <div class="brand-subtitle">WebUtils • Repo2Prompt</div>
      </div>
      <h1>Repo2Prompt</h1>
      <div class="toolbar">
        <a href="index.html">Back to index</a>
        <label for="zip-file">Load from file</label>
        <input id="zip-file" type="file" accept=".zip" />
        <button class="danger" id="clear-session" type="button">Clear</button>
      </div>
      <p>
        Paste a ZIP URL, pick the files you want, and copy a combined prompt-friendly
        payload.
      </p>
    </header>

    <div class="toolbar">
      <input
        id="zip-url"
        type="url"
        placeholder="Paste a .zip URL (for example: https://github.com/org/repo/archive/refs/heads/main.zip)"
        spellcheck="false"
      />
      <button class="primary" id="load-zip" type="button">Load ZIP</button>
      <span class="status-progress" id="zip-progress" hidden>
        <progress id="zip-progress-bar" max="100" value="0"></progress>
        <span id="zip-progress-text">0%</span>
      </span>
      <div class="status" id="status">No ZIP loaded.</div>
    </div>

    <main>
      <section class="panel">
        <h2>Files</h2>
        <div class="file-controls">
          <div style="display: flex; gap: 8px;">
            <button id="select-all" type="button" style="flex: 1;">Select All</button>
            <button id="deselect-all" type="button" style="flex: 1;">Deselect All</button>
          </div>
          <div style="display: flex; gap: 8px;">
            <button id="select-visible" type="button" style="flex: 1;">Select Visible</button>
            <button id="deselect-visible" type="button" style="flex: 1;">Deselect Visible</button>
          </div>
          <div style="font-size: 0.85rem; color: var(--muted);" id="file-count">Loading...</div>
          <details>
            <summary>Filter by extension</summary>
            <div style="display: flex; gap: 6px; margin-bottom: 6px;">
              <button id="filter-select-all" type="button" style="flex: 1; font-size: 0.8rem; padding: 4px 8px;">All</button>
              <button id="filter-deselect-all" type="button" style="flex: 1; font-size: 0.8rem; padding: 4px 8px;">None</button>
            </div>
            <div id="extension-filters"></div>
          </details>
          <details>
            <summary>Filter by regex</summary>
            <div style="display: flex; gap: 6px; margin-bottom: 6px;">
              <input
                id="regex-filter-input"
                type="text"
                placeholder="Enter regex pattern (e.g., ^src/.*\.js$)"
                spellcheck="false"
                style="flex: 1; padding: 6px 8px; border: 1px solid var(--stroke); border-radius: 8px; font-size: 0.85rem;"
              />
              <button id="regex-filter-clear" type="button" style="font-size: 0.8rem; padding: 4px 8px;">Clear</button>
            </div>
            <div style="font-size: 0.8rem; color: var(--muted);" id="regex-filter-status"></div>
          </details>
        </div>
        <div class="empty" id="file-empty">Load a ZIP to see text files.</div>
        <ul class="file-list" id="file-list"></ul>
      </section>
      <section class="panel">
        <div class="output-header">
          <h2>Output</h2>
          <span class="size" id="output-size">0 B</span>
          <button id="copy-output" type="button">Copy output</button>
        </div>
        <textarea id="output" readonly placeholder="Select files to build output."></textarea>
      </section>
      <div class="resize-handle" id="resize-handle"></div>
    </main>

    <footer>
      Built by <a href="https://www.mcindi.com" target="_blank" rel="noopener">McIndi Solutions LLC</a>.
    </footer>

    <dialog id="confirm-dialog">
      <form method="dialog" class="confirm-form">
        <h3 id="confirm-title">Confirm action</h3>
        <p id="confirm-message">Are you sure you want to continue?</p>
        <div class="confirm-actions">
          <button value="cancel" type="submit">Cancel</button>
          <button value="confirm" type="submit" class="primary" id="confirm-accept">
            Confirm
          </button>
        </div>
      </form>
    </dialog>

    <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js"></script>
    <script>
      const STORAGE_KEY_V1 = "webutils.repo2prompt.v1";
      const STORAGE_KEY_V2 = "webutils.repo2prompt.v2";
      const STORAGE_DB_NAME = "webutils-storage-v1";
      const STORAGE_STORE_NAME = "app-data";
      const urlInput = document.getElementById("zip-url");
      const loadButton = document.getElementById("load-zip");
      const fileInput = document.getElementById("zip-file");
      const clearButton = document.getElementById("clear-session");
      const statusEl = document.getElementById("status");
      const progressWrap = document.getElementById("zip-progress");
      const progressBar = document.getElementById("zip-progress-bar");
      const progressText = document.getElementById("zip-progress-text");
      const fileList = document.getElementById("file-list");
      const fileEmpty = document.getElementById("file-empty");
      const outputSize = document.getElementById("output-size");
      const outputArea = document.getElementById("output");
      const copyButton = document.getElementById("copy-output");
      const resizeHandle = document.getElementById("resize-handle");
      const mainElement = document.querySelector("main");

      const confirmDialog = document.getElementById("confirm-dialog");
      const confirmTitle = document.getElementById("confirm-title");
      const confirmMessage = document.getElementById("confirm-message");
      const confirmAccept = document.getElementById("confirm-accept");

      const textDecoder = new TextDecoder("utf-8");
      const textEncoder = new TextEncoder();
      let confirmResolve = null;
      let outputIndex = new Map();
      let storageDbPromise = null;

      const state = {
        url: "",
        files: [],
        extensionFilter: new Set(),
        regexFilter: "",
        visibleFiles: [],
      };

      const selectAllButton = document.getElementById("select-all");
      const deselectAllButton = document.getElementById("deselect-all");
      const selectVisibleButton = document.getElementById("select-visible");
      const deselectVisibleButton = document.getElementById("deselect-visible");
      const filterSelectAllButton = document.getElementById("filter-select-all");
      const filterDeselectAllButton = document.getElementById("filter-deselect-all");
      const regexFilterInput = document.getElementById("regex-filter-input");
      const regexFilterClearButton = document.getElementById("regex-filter-clear");
      const regexFilterStatus = document.getElementById("regex-filter-status");
      const fileCountDisplay = document.getElementById("file-count");
      const extensionFiltersContainer = document.getElementById("extension-filters");

      const requestConfirmation = ({ title, message, confirmText }) => {
        if (!confirmDialog || typeof confirmDialog.showModal !== "function") {
          return Promise.resolve(window.confirm(message || title));
        }
        confirmTitle.textContent = title;
        confirmMessage.textContent = message;
        confirmAccept.textContent = confirmText || "Confirm";
        return new Promise((resolve) => {
          confirmResolve = resolve;
          confirmDialog.showModal();
        });
      };

      confirmDialog.addEventListener("close", () => {
        if (!confirmResolve) {
          return;
        }
        const confirmed = confirmDialog.returnValue === "confirm";
        confirmResolve(confirmed);
        confirmResolve = null;
      });

      const setStatus = (text) => {
        statusEl.textContent = text;
      };

      const setProgress = (value, label) => {
        const normalized = Math.max(0, Math.min(100, Math.round(value)));
        progressBar.value = normalized;
        progressText.textContent = label || `${normalized}%`;
      };

      const showProgress = (label) => {
        progressWrap.hidden = false;
        setProgress(0, label || "0%");
      };

      const hideProgress = () => {
        progressWrap.hidden = true;
        setProgress(0, "0%");
      };

      const formatBytes = (bytes) => {
        if (bytes <= 0) {
          return "0 B";
        }
        const units = ["B", "KB", "MB", "GB"];
        const index = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1);
        const value = bytes / 1024 ** index;
        return `${value.toFixed(value >= 10 || index === 0 ? 0 : 1)} ${units[index]}`;
      };

      const isTextData = (data) => {
        const sample = data.subarray(0, 2000);
        for (const byte of sample) {
          if (byte === 0) {
            return false;
          }
        }
        return true;
      };

      const getStorageDb = () => {
        if (storageDbPromise) {
          return storageDbPromise;
        }
        if (!("indexedDB" in window)) {
          return Promise.reject(new Error("IndexedDB is not available."));
        }
        storageDbPromise = new Promise((resolve, reject) => {
          const request = indexedDB.open(STORAGE_DB_NAME, 1);
          request.onupgradeneeded = () => {
            const db = request.result;
            if (!db.objectStoreNames.contains(STORAGE_STORE_NAME)) {
              db.createObjectStore(STORAGE_STORE_NAME);
            }
          };
          request.onsuccess = () => resolve(request.result);
          request.onerror = () => reject(request.error || new Error("Failed to open storage."));
        });
        return storageDbPromise;
      };

      const readStoredPayload = async () => {
        const db = await getStorageDb();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORAGE_STORE_NAME, "readonly");
          const store = tx.objectStore(STORAGE_STORE_NAME);
          const request = store.get(STORAGE_KEY_V2);
          request.onsuccess = () => resolve(request.result || null);
          request.onerror = () => reject(request.error || new Error("Failed to read storage."));
        });
      };

      const writeStoredPayload = async (payload) => {
        const db = await getStorageDb();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORAGE_STORE_NAME, "readwrite");
          const store = tx.objectStore(STORAGE_STORE_NAME);
          store.put(payload, STORAGE_KEY_V2);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error || new Error("Failed to write storage."));
          tx.onabort = () => reject(tx.error || new Error("Failed to write storage."));
        });
      };

      const clearStoredPayload = async () => {
        const db = await getStorageDb();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORAGE_STORE_NAME, "readwrite");
          const store = tx.objectStore(STORAGE_STORE_NAME);
          store.delete(STORAGE_KEY_V2);
          tx.oncomplete = () => resolve();
          tx.onerror = () => reject(tx.error || new Error("Failed to clear storage."));
          tx.onabort = () => reject(tx.error || new Error("Failed to clear storage."));
        });
      };

      const saveState = async () => {
        try {
          const stateToSave = {
            schemaVersion: 1,
            savedAt: new Date().toISOString(),
            url: state.url,
            files: state.files,
            extensionFilter: Array.from(state.extensionFilter),
            regexFilter: state.regexFilter,
          };
          await writeStoredPayload(stateToSave);
        } catch (error) {
          setStatus("Storage full. Consider clearing or reloading the ZIP.");
        }
      };

      const applyLoadedState = (parsed) => {
        state.url = parsed && typeof parsed.url === "string" ? parsed.url : "";
        state.files = parsed && Array.isArray(parsed.files) ? parsed.files : [];
        state.extensionFilter = new Set(
          parsed && Array.isArray(parsed.extensionFilter) ? parsed.extensionFilter : []
        );
        state.regexFilter = parsed && typeof parsed.regexFilter === "string" ? parsed.regexFilter : "";
      };

      const loadState = async () => {
        try {
          const storedV2 = await readStoredPayload();
          if (storedV2 && typeof storedV2 === "object") {
            applyLoadedState(storedV2);
            return;
          }
        } catch (error) {
          await clearStoredPayload().catch(() => {});
        }

        const storedV1 = localStorage.getItem(STORAGE_KEY_V1);
        if (!storedV1) {
          return;
        }
        try {
          const parsed = JSON.parse(storedV1);
          applyLoadedState(parsed);
          await saveState();
          localStorage.removeItem(STORAGE_KEY_V1);
        } catch (error) {
          state.url = "";
          state.files = [];
          state.extensionFilter = new Set();
        }
      };

      const buildOutputData = () => {
        const selected = state.files.filter((file) => file.selected);
        if (selected.length === 0) {
          return { text: "", index: new Map() };
        }
        const boundary = createUniqueBoundary(selected);
        let text = "";
        let offset = 0;
        const index = new Map();

        selected.forEach((file, fileIndex) => {
          if (fileIndex > 0) {
            text += "\n\n";
            offset += 2;
          }
          const prev = fileIndex > 0 ? selected[fileIndex - 1].path : "";
          const context = prev ? `${prev} -> ${file.path}` : file.path;
          const header = `=== FILE BOUNDARY ${boundary} ${context} ===`;
          const block = `${header}\n${file.path}\n\n${file.content}`;
          index.set(file.path, offset);
          text += block;
          offset += block.length;
        });

        return { text, index };
      };

      const createUniqueBoundary = (files) => {
        let token = "";
        let prefix = "";
        do {
          token = Math.random().toString(36).slice(2, 10);
          prefix = `=== FILE BOUNDARY ${token}`;
        } while (files.some((file) => file.content.includes(prefix)));
        return token;
      };

      const updateOutput = () => {
        const outputData = buildOutputData();
        outputArea.value = outputData.text;
        outputIndex = outputData.index;
        const bytes = textEncoder.encode(outputData.text).length;
        outputSize.textContent = formatBytes(bytes);
      };

      const scrollOutputToFile = (filePath) => {
        const start = outputIndex.get(filePath);
        if (start == null) {
          return;
        }
        outputArea.focus();
        outputArea.setSelectionRange(start, start);
        const computedLineHeight = parseFloat(getComputedStyle(outputArea).lineHeight);
        const lineHeight = Number.isFinite(computedLineHeight) ? computedLineHeight : 18;
        const lineIndex = outputArea.value.slice(0, start).split("\n").length - 1;
        const targetTop = Math.max(0, lineIndex * lineHeight - outputArea.clientHeight * 0.2);
        outputArea.scrollTop = targetTop;
      };

      const getExtension = (path) => {
        const lastDot = path.lastIndexOf(".");
        return lastDot > 0 ? path.slice(lastDot) : "(no extension)";
      };

      const getUniqueExtensions = () => {
        const extensions = new Set();
        state.files.forEach((file) => {
          extensions.add(getExtension(file.path));
        });
        return Array.from(extensions).sort();
      };

      const renderExtensionFilters = () => {
        extensionFiltersContainer.innerHTML = "";
        const extensions = getUniqueExtensions();
        extensions.forEach((ext) => {
          const label = document.createElement("label");
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.value = ext;
          checkbox.checked = state.extensionFilter.has(ext);
          checkbox.addEventListener("change", () => {
            if (checkbox.checked) {
              state.extensionFilter.add(ext);
            } else {
              state.extensionFilter.delete(ext);
            }
            renderFiles();
          });
          label.append(checkbox, document.createTextNode(ext));
          extensionFiltersContainer.appendChild(label);
        });
      };

      const renderFiles = () => {
        fileList.innerHTML = "";
        if (state.files.length === 0) {
          fileEmpty.style.display = "block";
          fileCountDisplay.textContent = "No files";
          updateOutput();
          return;
        }

        fileEmpty.style.display = "none";
        const visibleFiles = state.files.filter((file) => {
          const matchesExtension = state.extensionFilter.has(getExtension(file.path));
          if (!matchesExtension) return false;
          
          if (!state.regexFilter) return true;
          try {
            const regex = new RegExp(state.regexFilter);
            return regex.test(file.path);
          } catch (error) {
            return false;
          }
        });

        state.visibleFiles = visibleFiles;
        fileCountDisplay.textContent = `${visibleFiles.length} of ${state.files.length} file${state.files.length === 1 ? "" : "s"}`;

        if (visibleFiles.length === 0) {
          const emptyMsg = document.createElement("li");
          emptyMsg.className = "empty";
          emptyMsg.textContent = "No files match the selected extensions.";
          fileList.appendChild(emptyMsg);
          updateOutput();
          return;
        }

        visibleFiles.forEach((file) => {
          const row = document.createElement("li");
          row.className = "file-row";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = Boolean(file.selected);
          checkbox.addEventListener("change", () => {
            file.selected = checkbox.checked;
            updateOutput();
            saveState();
          });

          row.addEventListener("click", (event) => {
            if (event.target === checkbox) {
              return;
            }
            file.selected = !file.selected;
            checkbox.checked = file.selected;
            updateOutput();
            saveState();
            if (file.selected) {
              scrollOutputToFile(file.path);
            }
          });

          const label = document.createElement("label");
          const title = document.createElement("div");
          title.className = "file-title";
          title.textContent = file.path;
          title.title = file.path;
          const meta = document.createElement("div");
          meta.className = "file-meta";
          meta.textContent = `${formatBytes(file.bytes)} | ${file.lines} lines`;
          label.append(title, meta);

          row.append(checkbox, label);
          fileList.appendChild(row);
        });

        updateOutput();
      };

      const ZIP_WORKER_SOURCE = `
        self.importScripts("https://cdn.jsdelivr.net/npm/fflate@0.8.2/umd/index.js");

        const isTextData = (data) => {
          const sample = data.subarray(0, 2000);
          for (const byte of sample) {
            if (byte === 0) {
              return false;
            }
          }
          return true;
        };

        self.onmessage = (event) => {
          try {
            const bytes = new Uint8Array(event.data.bytes);
            const entries = self.fflate.unzipSync(bytes);
            const paths = Object.keys(entries).sort();
            const total = paths.length;
            const decoder = new TextDecoder("utf-8");
            const files = [];
            let processed = 0;

            const emitProgress = () => {
              self.postMessage({ type: "progress", processed, total });
            };

            if (total > 0) {
              emitProgress();
            }

            paths.forEach((path) => {
              const data = entries[path];
              if (!path.endsWith("/") && isTextData(data)) {
                const content = decoder.decode(data);
                const lines = content.split("\\n").length;
                files.push({
                  path,
                  content,
                  bytes: data.length,
                  lines,
                });
              }

              processed += 1;
              if (processed === total || processed % 20 === 0) {
                emitProgress();
              }
            });

            self.postMessage({ type: "done", files, total });
          } catch (error) {
            self.postMessage({ type: "error", message: error && error.message ? error.message : "ZIP parse failed." });
          }
        };
      `;

      const parseZipInWorker = (bytes, onProgress) => {
        return new Promise((resolve, reject) => {
          const workerBlob = new Blob([ZIP_WORKER_SOURCE], { type: "application/javascript" });
          const workerUrl = URL.createObjectURL(workerBlob);
          const worker = new Worker(workerUrl);
          const cleanup = () => {
            worker.terminate();
            URL.revokeObjectURL(workerUrl);
          };

          worker.addEventListener("message", (event) => {
            const message = event.data || {};
            if (message.type === "progress") {
              if (typeof onProgress === "function") {
                onProgress(message.processed || 0, message.total || 0);
              }
              return;
            }
            if (message.type === "done") {
              cleanup();
              resolve(message);
              return;
            }
            if (message.type === "error") {
              cleanup();
              reject(new Error(message.message || "ZIP parse failed."));
            }
          });

          worker.addEventListener("error", (event) => {
            cleanup();
            reject(new Error(event.message || "ZIP parse failed."));
          });

          const transferable = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
          worker.postMessage({ bytes: transferable }, [transferable]);
        });
      };

      const parseZip = async (bytes) => {
        setStatus("Processing ZIP...");
        showProgress("Preparing...");
        try {
          const result = await parseZipInWorker(bytes, (processed, total) => {
            if (!total) {
              setProgress(0, "0%");
              return;
            }
            const percent = (processed / total) * 100;
            setProgress(percent, `${Math.round(percent)}% (${processed}/${total})`);
          });

          const files = (result.files || []).map((file) => ({
            path: file.path,
            content: file.content,
            selected: true,
            bytes: file.bytes,
            lines: file.lines,
          }));

          state.files = files;
          state.extensionFilter = new Set(getUniqueExtensions());
          saveState();
          renderExtensionFilters();
          renderFiles();
          setStatus(`Loaded ${files.length} text file${files.length === 1 ? "" : "s"}.`);
        } catch (error) {
          setStatus("Could not read the ZIP file. Try a different download.");
        } finally {
          hideProgress();
        }
      };

      const handleFileLoad = (file) => {
        if (!file) {
          return;
        }
        setStatus("Loading ZIP from file...");
        showProgress("Waiting...");
        const reader = new FileReader();
        reader.onload = async () => {
          state.url = "";
          urlInput.value = "";
          saveState();
          await parseZip(new Uint8Array(reader.result));
        };
        reader.onerror = () => {
          hideProgress();
          setStatus("Could not read the ZIP file.");
        };
        reader.readAsArrayBuffer(file);
      };

      const handleLoad = async () => {
        const url = urlInput.value.trim();
        if (!url) {
          setStatus("Paste a ZIP URL to continue.");
          return;
        }

        setStatus("Downloading ZIP...");
        showProgress("Downloading...");
        try {
          const response = await fetch(url);
          if (!response.ok) {
            hideProgress();
            setStatus(`Download failed (${response.status}). Try loading a ZIP file instead.`);
            return;
          }
          const buffer = await response.arrayBuffer();
          state.url = url;
          saveState();
          await parseZip(new Uint8Array(buffer));
        } catch (error) {
          hideProgress();
          setStatus("Download failed. Check the URL or CORS settings, or load a ZIP file.");
        }
      };

      const clearSession = async () => {
        const confirmed = await requestConfirmation({
          title: "Clear the current session?",
          message: "This removes the loaded ZIP and clears saved output.",
          confirmText: "Clear",
        });
        if (!confirmed) {
          return;
        }
        state.url = "";
        state.files = [];
        state.extensionFilter = new Set();
        await clearStoredPayload().catch(() => {
          setStatus("Could not clear saved session data.");
        });
        localStorage.removeItem(STORAGE_KEY_V1);
        urlInput.value = "";
        fileInput.value = "";
        outputArea.value = "";
        outputSize.textContent = "0 B";
        hideProgress();
        renderExtensionFilters();
        renderFiles();
        setStatus("No ZIP loaded.");
      };

      copyButton.addEventListener("click", async () => {
        const text = outputArea.value;
        if (!text) {
          setStatus("No output to copy.");
          return;
        }
        try {
          await navigator.clipboard.writeText(text);
          setStatus("Output copied to clipboard.");
        } catch (error) {
          outputArea.focus();
          outputArea.select();
          document.execCommand("copy");
          setStatus("Output copied to clipboard.");
        }
      });

      loadButton.addEventListener("click", handleLoad);
      selectAllButton.addEventListener("click", () => {
        state.files.forEach((file) => {
          file.selected = true;
        });
        renderFiles();
        saveState();
        setStatus("Selected all files.");
      });

      deselectAllButton.addEventListener("click", () => {
        state.files.forEach((file) => {
          file.selected = false;
        });
        saveState();
        renderFiles();
        setStatus("Deselected all files.");
      });

      selectVisibleButton.addEventListener("click", () => {
        state.visibleFiles.forEach((file) => {
          file.selected = true;
        });
        renderFiles();
        saveState();
        setStatus(`Selected ${state.visibleFiles.length} visible file${state.visibleFiles.length === 1 ? "" : "s"}.`);
      });

      deselectVisibleButton.addEventListener("click", () => {
        state.visibleFiles.forEach((file) => {
          file.selected = false;
        });
        renderFiles();
        saveState();
        setStatus(`Deselected ${state.visibleFiles.length} visible file${state.visibleFiles.length === 1 ? "" : "s"}.`);
      });

      filterSelectAllButton.addEventListener("click", () => {
        const checkboxes = extensionFiltersContainer.querySelectorAll("input[type='checkbox']");
        checkboxes.forEach((checkbox) => {
          checkbox.checked = true;
          state.extensionFilter.add(checkbox.value);
        });
        renderFiles();
        saveState();
      });

      filterDeselectAllButton.addEventListener("click", () => {
        const checkboxes = extensionFiltersContainer.querySelectorAll("input[type='checkbox']");
        checkboxes.forEach((checkbox) => {
          checkbox.checked = false;
          state.extensionFilter.delete(checkbox.value);
        });
        renderFiles();
        saveState();
      });

      regexFilterInput.addEventListener("input", () => {
        state.regexFilter = regexFilterInput.value.trim();
        let statusText = "";
        if (state.regexFilter) {
          try {
            new RegExp(state.regexFilter);
            statusText = "✓ Valid regex";
            regexFilterStatus.style.color = "var(--muted)";
          } catch (error) {
            statusText = `✗ ${error.message}`;
            regexFilterStatus.style.color = "var(--warn)";
          }
        }
        regexFilterStatus.textContent = statusText;
        renderFiles();
        saveState();
      });

      regexFilterClearButton.addEventListener("click", () => {
        state.regexFilter = "";
        regexFilterInput.value = "";
        regexFilterStatus.textContent = "";
        renderFiles();
        saveState();
      });

      fileInput.addEventListener("change", (event) => {
        const file = event.target.files[0];
        if (file) {
          handleFileLoad(file);
        }
        fileInput.value = "";
      });
      clearButton.addEventListener("click", clearSession);
      urlInput.addEventListener("change", () => {
        state.url = urlInput.value.trim();
        saveState();
      });

      // Resize handle logic
      let isResizing = false;
      let startX = 0;
      let startPos = 380;

      resizeHandle.addEventListener("mousedown", (e) => {
        isResizing = true;
        startX = e.clientX;
        startPos = parseInt(getComputedStyle(mainElement).getPropertyValue("--split-pos"), 10) || 380;
        mainElement.classList.add("resizing");
      });

      document.addEventListener("mousemove", (e) => {
        if (!isResizing) return;
        const delta = e.clientX - startX;
        const newPos = Math.max(240, Math.min(startPos + delta, mainElement.clientWidth - 240));
        mainElement.style.setProperty("--split-pos", `${newPos}px`);
      });

      document.addEventListener("mouseup", () => {
        if (isResizing) {
          isResizing = false;
          mainElement.classList.remove("resizing");
        }
      });

      const initialize = async () => {
        await loadState();
        if (state.url) {
          urlInput.value = state.url;
        }
        if (state.files.length > 0 && state.extensionFilter.size === 0) {
          state.extensionFilter = new Set(getUniqueExtensions());
        }
        if (state.regexFilter) {
          regexFilterInput.value = state.regexFilter;
        }
        renderExtensionFilters();
        renderFiles();
      };

      initialize();
    </script>
  </body>
</html>
